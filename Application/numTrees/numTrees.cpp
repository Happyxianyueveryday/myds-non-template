
// 本题是二叉搜索树中最经典的问题之一，虽然面试题中出现的次数较少，但是是考研选择题中的高频考点
// 本题所使用的算法是: 从1,2...,n中选择一个值k作为根结点的值作为根节点的值，然后这时根节点的左子树是由值1,2,...,k-1共(k-1)个结点的二叉搜索树的种类数，右子树是由值k+1,...,n共(n-k)个结点的二叉搜索树的种类数，左子树和右子树的种类数相乘就得到根结点为k时的种类数，依次将k取0,..,n时得到的情况相加即可得到总的种类数，因此这个问题就变成了一个递归问题，可以使用迭代算法实现

class Solution {
public:
    int numTrees(int n) {
        int res[n+1];
        memset(res, 0, (n+1)*sizeof(int));
        res[0]=1; res[1]=1;
        
        for(int i=2;i<=n;i++)   // 计算总结点数为i个时的二叉搜索树种类数
        {
            for(int k=1;k<=i;k++)
            {
                int temp=res[k-1]*res[i-k];
                res[i]+=temp;
            }
        }

        return res[n];
    }
};